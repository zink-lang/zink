<!DOCTYPE HTML>
<html lang="en" class="dark sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Zink Language</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "dark";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('dark')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Zink Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/zink-lang/zink" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/clearloop/zink">Zink</a> is a powerful toolchain revolutionizing smart contract development
on Ethereum, it is designed to bridge the gap between WebAssembly and the Ethereum
Virtual Machine.</p>
<p>At its core, <a href="https://github.com/clearloop/zink/tree/main/compiler">zinkc</a>, the Zink compiler, <strong>takes WASM bytecode as the source
code and transforms it into EVM bytecode</strong> for seamless execution on the Ethereum
blockchain. This optimization ensures efficient and reliable execution of smart
contracts on Ethereum.</p>
<p>This guide is intended to serve a number of purposes and within you’ll find:</p>
<ul>
<li><a href="https://zink-lang.org/budgets">The Bounty issues</a></li>
<li><a href="https://docs.zink-lang.org/rustdocs">The rustdocs of the zink project</a></li>
<li><a href="/compiler">The design of the zink compiler</a></li>
<li><a href="/styles">The rust guide of zink projects</a></li>
</ul>
<p>…and more! The source for this guide <a href="https://github.com/clearloop/zink/tree/main/docs">lives on GitHub</a> and contributions are welcome!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<p>This tutorial walks through creating a simple add-two program and compiles it with description how everything works.</p>
<ul>
<li><a href="tutorial//tutorial/create-zink-project">Creating <code>add-two</code></a></li>
<li><a href="tutorial//tutorial/compile-zink-project">Compiling <code>add-two</code></a></li>
</ul>
<p>For the overall instructions:</p>
<pre><code class="language-bash"># Install zink toolchain
cargo install zinkup

# Create project
elko new add-two

# Compile it
cd add-two &amp;&amp; elko build
ls target/add-two.bin
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-zink-project"><a class="header" href="#creating-zink-project">Creating Zink Project</a></h1>
<p>For creating a zink project, we need to install the zink toolchain <code>zinkup</code>
from <code>crates.io</code> first, the package manager <code>elko</code> will be installed along
with other tools:</p>
<pre><code class="language-bash">cargo install zinkup
elko -h
</code></pre>
<p>Now, let’s create a zink project:</p>
<pre><code class="language-bash">elko new my-awesome-contract
Created zink project `my-awesome-contract`
</code></pre>
<p>the Zink projects are based on the <a href="https://doc.rust-lang.org/cargo/reference/manifest.html">cargo projects</a>, you can install
dependencies you need with <code>cargo</code>, the basic <code>Cargo.toml</code> will be like:</p>
<pre><code class="language-toml"># ...

[lib]
crate-type = [ "cdylib" ]

[dependencies]
zink = "0.1.0"

# ...
</code></pre>
<p>open <code>my-awesome-contract/src/lib.rs</code></p>
<pre><code class="language-rust">//! my-awesome-project
#![no_std]

// For the panic handler.
#[cfg(not(test))]
extern crate zink;

/// Adds two numbers together.
#[no_mangle]
pub extern "C" fn addition(x: u64, y: u64) -&gt; u64 {
    x + y
}</code></pre>
<p>you’ll see a standard <code>WASM</code> library in rust:</p>
<ol>
<li><code>#![no_std]</code> means we don’t need the std library in this project.</li>
<li><code>extern crate zink</code> is for importing the panic handler from library <code>zink</code> for this project.</li>
<li><code>#[no_mangle]</code> is for exporting function <code>addition</code> to WASM, and this will be one the methods
of your contracts.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiling-zink-project"><a class="header" href="#compiling-zink-project">Compiling Zink Project</a></h1>
<p>We have got a zink project after <a href="tutorial//tutorial/create-zink-project.html">creating-zink-project</a>, now it’s time to compile
it to EVM bytecode!</p>
<pre><code class="language-bash"># Enter our project
cd my-awesome-project

# Build the project
elko build

# Check the outputs
ls target/zink
my-awesome-project.wasm my-awesome-project.bin
</code></pre>
<p>you’ll see a <code>my-awesome-project.bin</code> file under <code>target/zink</code>, and that’s it!</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works?</a></h2>
<p>first, <code>elko</code> compiles the cargo project to WASM with:</p>
<pre><code class="language-bash">cargo b --target wasm32-unknown-unknown --release
</code></pre>
<p>then, there will be some logic inside <code>elko</code>, running <code>wasm-opt</code> for our output
WASM binary</p>
<pre><code class="language-bash"># if you have wasm-opt installed on your machine, you can try the same
mkdir -p target/zink
wasm-opt -O4 target/wasm32-unknown/unknown/release/my-awesome-project.wasm -o target/zink/my-awesome-project.wasm
</code></pre>
<p>finally we use <code>zinkc</code> to compile the wasm to EVM bytecode:</p>
<pre><code class="language-bash"># For reproducing it in your command line
zinkc target/zink/my-awesome-project.wasm
mv my-awesome-project.bin target/zink
</code></pre>
<h2 id="future-plans-todo"><a class="header" href="#future-plans-todo">Future plans (TODO)</a></h2>
<ol>
<li>Generate the ABI as well.</li>
<li>Add command for deploying the bytecode to EVM chain with RPC endpoints.</li>
<li>Test suite</li>
<li>…</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>This chapter provides various zink examples in rust:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>knowledges</th><th>description</th></tr></thead><tbody>
<tr><td><a href="examples//examples/add-two.html"><code>add-two</code></a></td><td><code>params</code></td><td>basic program in zink</td></tr>
<tr><td><a href="examples//examples/fibonacci.html"><code>fibonacci</code></a></td><td><code>calls</code>, <code>recursion</code>, <code>if-block</code></td><td>recursion implementation</td></tr>
<tr><td><a href="examples//examples/log.html"><code>log</code></a></td><td><code>log</code></td><td>log APIs</td></tr>
<tr><td><a href="examples//examples/select.html"><code>select</code></a></td><td><code>wasm built-in functions</code></td><td>program with extra instruction <code>select</code> from WASM</td></tr>
<tr><td><a href="examples//examples/storage.html"><code>storage</code></a></td><td><code>storage</code></td><td>storage operations</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="addtwo"><a class="header" href="#addtwo">AddTwo</a></h1>
<pre><code class="language-rust">//! Addition example.
#![no_std]

// for the panic handler.
#[cfg(not(test))]
extern crate zink;

/// Adds two numbers together.
#[no_mangle]
pub extern "C" fn addition(x: u64, y: u64) -&gt; u64 {
    x + y
}</code></pre>
<p>A basic addition program in zink</p>
<pre><code class="language-wasm">(module
    (func (param i32) (param i32) (result i32)
    (local.get 0)
    (local.get 1)
    (i32.add)
    )
)
</code></pre>
<p>Requires:</p>
<ul>
<li>Get params from locals</li>
<li>Process basic operand</li>
<li>Return data from the result type</li>
</ul>
<pre><code class="language-text">6000356020350160005260206000f3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fibonacci"><a class="header" href="#fibonacci">Fibonacci</a></h1>
<pre><code class="language-rust">//! fibonacci example.
#![no_std]

// for the panic handler.
#[cfg(not(test))]
extern crate zink;

/// Calculates the nth fibonacci number.
#[no_mangle]
pub extern "C" fn fibonacci(n: usize) -&gt; usize {
    recursion(n)
}

/// Calculates the nth fibonacci number using recursion.
#[no_mangle]
pub extern "C" fn recursion(n: usize) -&gt; usize {
    if n &lt; 2 {
        n
    } else {
        recursion(n - 1) + recursion(n - 2)
    }
}</code></pre>
<p>A recursion example, complex in bytecode</p>
<pre><code class="language-wasm">(module
  (type (;0;) (func (param i32) (result i32)))
  (func (;0;) (type 0) (param i32) (result i32)
    local.get 0
    call 1)
  (func (;1;) (type 0) (param i32) (result i32)
    (local i32)
    local.get 0
    i32.const 2
    i32.ge_u
    if  ;; label = @1
      loop  ;; label = @2
        local.get 0    ;; 1
        i32.const 1    ;; 2
        i32.sub        ;; 1
        call 1         ;; 1
        local.get 1    ;; 2
        i32.add        ;; 1
        local.set 1    ;; 0
        local.get 0    ;; 1
        i32.const 2    ;; 2
        i32.sub        ;; 1
        local.tee 0    ;; 1
        i32.const 1    ;; 2
        i32.gt_u       ;; 1
        br_if 0 (;@2;) ;; 2 -&gt; 0
      end
    end
    local.get 0
    local.get 1
    i32.add))
</code></pre>
<p>A more complex implementation of locals ( params + local variables) is introduced in this example,
control flow <code>br_if</code> and <code>loop</code> are compiled as well.</p>
<pre><code>600035586010565b60005260206000f35b906000816002600190031015603d575b8160019003586010565b8101905081600290038092506001106020575b8181019150509060040156
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="log"><a class="header" href="#log">Log</a></h1>
<pre><code class="language-rust">//! Addition example.
#![no_std]

// for the panic handler.
#[cfg(not(test))]
extern crate zink;

use zink::Event;

/// A `Ping` event.
#[derive(Event)]
struct Ping;

#[no_mangle]
pub extern "C" fn log1() {
    Ping.log1(b"pong");
}</code></pre>
<p>The log API of zink is derived by the trait <code>Event</code> which provides methods
<code>log0</code>, <code>log1</code>, <code>log2</code>, <code>log3</code>, <code>log4</code>. We current only supports static
bytes in this API.</p>
<pre><code class="language-wasm">(module
  (type (;0;) (func))
  (type (;1;) (func (param i32 i32 i32 i32)))
  (import "evm" "log1" (func (;1;) (type 1)))
  (import "env" "memory" (memory (;0;) 17))
  (func (;1;) (type 0)
    i32.const 1048576
    i32.const 4
    i32.const 1048580
    i32.const 4
    call 0)
  (export "log1" (func 1))
  (data (;0;) (i32.const 1048576) "Pingpong"))
</code></pre>
<p>The static byte array will be compiled to the data section of wasm, <code>zinkc</code>
gets it from the data section then process it to the logging interfaces.</p>
<pre><code>63706f6e676350696e6760005260206000a15f5ff3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="select"><a class="header" href="#select">Select</a></h1>
<pre><code class="language-rust">//! if-else example.
#![no_std]

// for the panic handler.
#[cfg(not(test))]
extern crate zink;

/// Simple if-else condition
#[no_mangle]
pub extern "C" fn if_else(x: u64, y: u64) -&gt; u64 {
    if x &gt; y {
        x
    } else {
        y
    }
}
</code></pre>
<p>Code block selecting value with if-else will be compiled to instruction <code>select</code> in WASM</p>
<pre><code class="language-wasm">(module
  (type (;0;) (func (param i64 i64) (result i64)))
  (func $if_else (type 0) (param i64 i64) (result i64)
    local.get 0
    local.get 1
    local.get 0
    local.get 1
    i64.gt_u
    select))
</code></pre>
<p>Since EVM bytecode doesn’t have similar instruction, we have to implement it ourselves, the solution
is introduce a <code>select</code> function in the extra code section provided by zink compiler, jump to there
and jump back just like calling a real function.</p>
<pre><code>60003560203560003560203510589190601c575b60005260206000f35b5060060156
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<pre><code class="language-rust">// for the panic handler.
#[cfg(not(test))]
extern crate zink;

use zink::Storage;

/// It gets expanded to 'Counter' struct
/// that implements zink::Storage trait
/// (::set and ::get)
///
/// Storage key is taken based on macro order
/// (e.g this macro is first and only in this project,
/// so it will take 0x0 contract storage key)
#[zink::storage]
pub type Counter = i32;

/// Set value to storage and get it
#[no_mangle]
pub unsafe extern "C" fn set_and_get(value: i64) -&gt; i64 {
    Counter::set(value);
    Counter::get()
}</code></pre>
<p>Simple storage IO for numbers.</p>
<pre><code class="language-wasm">(module
  (type (;0;) (func (param i64) (result i64)))
  (type (;1;) (func (param i64 i64)))
  (import "zink" "sload" (func (;0;) (type 0)))
  (import "zink" "sstore" (func (;1;) (type 1)))
  (func (type 0) (param i64) (result i64)
        i64.const 0
        local.get 0
        call 1
        i64.const 0
        call 0))
</code></pre>
<p>Set and get number parameter with storage here.</p>
<pre><code>60006000355891601b565b600058906021565b60005260206000f35b55600501565b549060050156
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="style-guide"><a class="header" href="#style-guide">Style Guide</a></h1>
<p>This style guide is for writing zink projects with <code>rust</code> as the
source language.</p>
<p>We don’t need any styles for now, just writing anything you want,
and the zinkc compiler will handle the rest of everything.</p>
<p>For the futures plans of <code>events</code>, <code>selector</code>, <code>storage</code> and <code>...</code>
plz keep tuned, they will be implemented in <a href="https://github.com/clearloop/zink/milestone/2"><code>v0.2.0</code></a> : )</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler"><a class="header" href="#compiler">Compiler</a></h1>
<p>The chapter illustrates the design of the zink compiler, so mostly,
we are talking about <code>wat</code> and EVM bytecode <code>Mnemonic</code> here:</p>
<ul>
<li><a href="compiler/./arithmetic.html">Arithmetic</a></li>
<li><a href="compiler/./calls.html">Calls</a></li>
<li><a href="compiler/./control-flow.html">Control Flow</a></li>
<li><a href="compiler/./locals.html">Locals</a></li>
<li><a href="compiler/./recursion.html">Recursion</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arithmetic"><a class="header" href="#arithmetic">Arithmetic</a></h1>
<p>The arithmetic operators have a lot of differences between WASM and EVM bytecode,
all of the operand requires the order of the stack are reserved…</p>
<h2 id="sub-div-mod-and-bitwise-operand"><a class="header" href="#sub-div-mod-and-bitwise-operand">Sub, Div, Mod and Bitwise Operand</a></h2>
<pre><code class="language-wasm">i32.const 2       ;; PUSH1 0x02
i32.const 1       ;; PUSH1 0x01
sub               ;; SWAP1
                  ;; SUB
</code></pre>
<p>This <code>SWAP1</code> sticks to all of these reversed order instructions, will introduce
macros to optimize it in <code>v0.3.0</code>.</p>
<h2 id="comparison"><a class="header" href="#comparison">Comparison</a></h2>
<p>The order of comparison are reversed as well, but however, they are paired!</p>
<pre><code class="language-wasm">i32.const 1    ;; PUSH1 0x01
i32.const 0    ;; PUSH1 0x00
gt             ;; LT
</code></pre>
<p>This is insane, but works perfectly, don’t think too much about it, focus
on if the output is <code>0</code> or <code>1</code> ;)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calls"><a class="header" href="#calls">Calls</a></h1>
<p>The function calls are compiled by order in zink, the first call
in order (index 0) will be the main function ( to be updated ).</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>There are only internal functions and external functions in zink
project for now.</p>
<h3 id="internal-functions"><a class="header" href="#internal-functions">Internal Functions</a></h3>
<p>The parameters of the internal functions will be queued to the
<a href="compiler/./locals.html">locals</a> of the them and taking the first <code>n</code> stack
for storing them.</p>
<h3 id="external-functions"><a class="header" href="#external-functions">External Functions</a></h3>
<p>Same as internal functions, will be updated once have the design
of selector in <a href="https://github.com/clearloop/zink/milestone/2">v0.2.0</a></p>
<h3 id="extended-functions"><a class="header" href="#extended-functions">Extended Functions</a></h3>
<p>We have also introduces extended functions inside the compiler
for complete the difference between EVM bytecode and WASM,
see the implementation <a href="compiler/./control-flow.html#select">select</a> as example.</p>
<h3 id="main-function"><a class="header" href="#main-function">Main Function</a></h3>
<p>You may never meet this because it is embedded in the compiled
bytecode, but it is the entry of zink programs.</p>
<p>It takes parameters from the <code>calldata</code> by order, for loading
32-byte parameters, it will process</p>
<pre><code class="language-yul">// parameter 1
PUSH1 0x00
calldataload

// parameter 2
PUSH1 0x20
calldataload
</code></pre>
<h2 id="layout"><a class="header" href="#layout">Layout</a></h2>
<p>Each function in zink is started with <code>JUMPDEST</code> in the layout
of the bytecode for the insane jumping…</p>
<p>Each function call’s stack starts with <code>PC</code> which stores the last active
program counter for the program for jumping back to the main process since
the callee functions could be called by any functions but not only one.</p>
<p>There is a tricky problem that <strong>how to detect the last pc before jumping</strong>,
for solving this, <code>zinkc</code> registers the original <code>PC</code> to the jump table when
meeting jumps and relocates them after compiling all functions.</p>
<h3 id="example-addition"><a class="header" href="#example-addition">Example Addition</a></h3>
<pre><code class="language-wasm">(module
  (func (export "main") (param i32) (param i32) (result i32)
    (call $add (local.get 0) (local.get 1))
  )

  (func $add (param i32 i32) (result i32)
    (local.get 0)
    (local.get 1)
    (i32.add)
  )
)
</code></pre>
<p>Let’s assume we are calling an <code>add</code> function with parameters <code>1, 1</code> and
now we are at the first byte right before it:</p>
<pre><code class="language-yul">/* 0x00 */  PUSH1 0x01    // push the first parameter on the stack
/* 0x02 */  PUSH1 0x01    // push the second  parameter on the stack
/*      */                //
/*      */                //
/* 0x04 */  pc            // the first byte before calling the callee function
/*      */                //
/*      */                //
/* 0x05 */  PUSH1 0x42    // This 0x42 will be reloacted by `zinkc`
/*      */                //
/*      */                //
/* 0x07 */  jump          // jump to the callee function
/*      */                //
/*      */                //
/* 0x08 */  jumpdest      // the pc for jumping back from the callee function.
/*      */                //
/*      */                // the rest logic of the main process.
/*      */                //
/*      */                //
/* 0x42 */  jumpdest      // the first byte of the callee function
/*      */                //
/*      */                //
/* 0x43 */  add           // for the current stack: [PC, 0x02]
/*      */                //
/*      */                //
/* 0x44 */  SWAP1         // shift the stored PC to the top of the stack
/*      */                //
/*      */                //
/* 0x45 */  PUSH1 0x04    // the jumpdest is the original pc + 4 bcz we have
/* 0x47 */  add           // `push1`, `0x42`, `jump`, `jumpdest` queued after
/*      */                // `pc`.
/*      */                //
/*      */                //
/* 0x48 */  jump          // This 0x07 will be reloacted by `zinkc`

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>EVM doesn’t have instructions for the custom control flows, however
zink implements them with <code>JUMPI</code> and <code>JUMP</code>, which includes:</p>
<ul>
<li><code>if</code></li>
<li><code>block</code></li>
<li><code>loop</code></li>
<li><code>else</code></li>
<li><code>select</code></li>
<li><code>br</code></li>
<li><code>br_if</code></li>
<li><code>br_table</code></li>
</ul>
<h2 id="if-else"><a class="header" href="#if-else">If-Else</a></h2>
<p>The beginning of an if construct with an implicit then block, plus and else block.</p>
<p>The basic logic is, if non-zero, enter the if block, otherwise jump to the else block
or the end of the if condition.</p>
<pre><code class="language-wasm">(if (result i32)
  (local.get 0)
  (then (i32.const 7))
  (else (i32.const 8)))
</code></pre>
<p>The expected result is</p>
<div class="table-wrapper"><table><thead><tr><th>Input</th><th>Result</th></tr></thead><tbody>
<tr><td>1</td><td>7</td></tr>
<tr><td>0</td><td>8</td></tr>
</tbody></table>
</div>
<p>so in the compiled bytecode, the code snippet above will be</p>
<pre><code class="language-yul">PUSH1 0x00       // Load the params at 0x00
calldataload

iszero           // if is zero, jump to 0x0c, the else block.
PUSH1 0x0c
jumpi

push1 0x07       // if is non-zero, enters the if block.
                 // push 0x07 on stack.

PUSH1 0x0f       // jump to the end of the else block.
jump

jumpdest         // destination of the else block, push 0x08
push1 0x08       // on stack.


jumpdest         // the end of the else block.


PUSH1 0x00       // pack the result and return...
mstore
PUSH1 0x20
PUSH1 0x00
return
</code></pre>
<h2 id="select-1"><a class="header" href="#select-1">Select</a></h2>
<p>The <code>select (0x1B)</code> instruction comes from WebAssembly, it selects
one of its first two operands based on whether its third operand is
zero or not.</p>
<p>Simple rust conditions in rust will be compiled to <code>select</code>.</p>
<pre><code class="language-rust">pub extern "C" fn if_else(x: u64, y: u64) -&gt; u64 {
    if x &gt; y {
        x
    } else {
        y
    }
}</code></pre>
<p>As we can see in the example above, we simply returns the bigger
number from the 2 parameters, the logic in the two blocks of
<code>if-else</code> is explicit direct, that will be compiled to <code>select</code>.</p>
<pre><code class="language-wasm">(module
  (type (;0;) (func (param i64 i64) (result i64)))
  (func $if_else (type 0) (param i64 i64) (result i64)
    local.get 0
    local.get 1
    local.get 0
    local.get 1
    i64.gt_u
    select))
</code></pre>
<p>Since EVM doesn’t have instruction like <code>select</code>, we need to provide
it ourselves in our implementation like an external function, if zero
pop the value on the top of the stack.</p>
<pre><code class="language-rust">const SELECT: [OpCode; 6] = [
    OpCode::JUMPDEST,
    OpCode::POP,
    OpCode::PUSH1,
    OpCode::Data(0x06),
    OpCode::ADD,
    OpCode::JUMP,
];</code></pre>
<p>In the compiled code, we need to combine this function <code>select</code> with
<code>jumpi</code> in EVM.</p>
<pre><code class="language-yul">PUSH1 0x00      // Load the parameters.
calldataload

PUSH1 0x20
calldataload

PUSH1 0x00
calldataload

PUSH1 0x20
calldataload

lt               // Compiled to `lt` because of the result of this
                 // instruction is oppsited between EVM and WASM.

pc
swap2            // shift
swap1
PUSH1 0x1c
jumpi            // `jumpi` for the if condition.
JUMPDEST

PUSH1 0x00       // Returns the value.
mstore
PUSH1 0x20
PUSH1 0x00
return

JUMPDEST         // Function select starts here.
pop
PUSH1 0x06
add
jump
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="locals"><a class="header" href="#locals">Locals</a></h1>
<p>There are two usages of locals in zink.</p>
<ol>
<li>The parameters of functions are loaded as locals.</li>
<li>local defined variables in functions.</li>
</ol>
<div class="table-wrapper"><table><thead><tr><th></th><th>fn params</th><th>local variables</th></tr></thead><tbody>
<tr><td>stack</td><td>locals[..n]</td><td>locals[n..]</td></tr>
</tbody></table>
</div>
<h2 id="function-parameters"><a class="header" href="#function-parameters">Function Parameters</a></h2>
<p>Let’s go through the <code>add-two</code> example:</p>
<pre><code class="language-wasm">(module
    (func (param (;0;) i32) (param (;1;) i32) (result i32)
    (local.get 0)
    (local.get 1)
    (i32.add)
    )
)
</code></pre>
<p><code>(param (;0;) i32)</code> and <code>(param (;1;) i32)</code> will be pushed to the function
locals with index <code>0</code> and index <code>1</code> with their type <code>i32</code> recorded.</p>
<p><code>zinkc</code> gets the defined local at index <code>0</code> when reaching <code>(local.get 0)</code>,
at index <code>1</code> for <code>(local.get 1)</code>, for example, for <code>(local.get 0)</code>, it will
be translated to:</p>
<pre><code class="language-yul">push1 0x00
calldataload
</code></pre>
<p>for <code>(local.get 1)</code>, that would be</p>
<pre><code class="language-yul">push1 0x20
calldataload
</code></pre>
<p>You may have problem why we <code>PUSH1 0x20</code> while getting local at index <code>1</code>, the
answer is that this offset is calculated by the size of the parameters.</p>
<p>The <code>CALLDATALOAD</code> operator has stack input <code>i</code> and output <code>data[i]</code> while <code>data[i]</code>
is a <code>32-byte</code> value starting from the given offset of the calldata, so the minimal
size of our types will be <code>32-byte</code>, therefore, we align all types sizes to <code>32-byte</code>
in <code>zinkc</code>.</p>
<blockquote>
<p>WARN: We don’t care about the originals offset of the parameters in WASM bcz we will
serialize them into our locals and calculate the offsets on our own when need anyway.</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>type</th><th>size</th><th>aligned size</th></tr></thead><tbody>
<tr><td><code>i32</code></td><td><code>[u8;4]</code></td><td><code>[u8;32]</code></td></tr>
<tr><td><code>i64</code></td><td><code>[u8;8]</code></td><td><code>[u8;32]</code></td></tr>
</tbody></table>
</div>
<p>It is a waste of resources but sadly this is also how EVM works ))</p>
<h2 id="local-variables"><a class="header" href="#local-variables">Local Variables</a></h2>
<p>The locals variables will take the stack items right after the function
parameters, for example:</p>
<pre><code class="language-wasm">(func (result i32)
  (local i32)
  i32.const 42
  local.set 0
  local.get 0)
</code></pre>
<p>In the program above, we set and get <code>42</code> to local variable <code>0</code> and returns it.</p>
<p>While compiling this function, <code>zinkc</code> will push local variable <code>0</code> on the stack
with an initializing value <code>0</code> first, getting with <code>dup</code> and setting with <code>swap</code>
and <code>drop</code>.</p>
<pre><code class="language-yul">PUSH1 0x00       // initializing value 0 for local 0
                 //
                 //
PUSH1 0x28       // push value 42 on stack, the current stack is [0, 42]
                 //
                 //
SWAP1            // swap the value on the top of the stack to local 0 and
DROP             // drop the previous value of it for cleaning stack, `swapn`
                 // is calculated by `zinkc`. current stack: [42]
                 //
                 //
DUP1             // dup the value of local 0 and push it on the top of the
                 // stack, `dupn` is calculated by `zinkc`.
                 //
                 //
DROP             // clean the stack before returning results.
</code></pre>
<p>As we can see, the usages of <code>get</code> and <code>set</code> is verbose with <code>swap</code> and <code>dup</code>,
it is for adapting any usages but not necessary for all of them, however, we
will introduce optimizer for this in <code>v0.4.0</code>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursion"><a class="header" href="#recursion">Recursion</a></h1>
<p>The main function of zink project doesn’t support recursion for now :)</p>
<p>The callee functions support, plz see <a href="compiler//examples/fibonacci.html">fibonacci</a> for example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-1"><a class="header" href="#storage-1">Storage</a></h1>
<p>The storage keys in Zink is slot based, for example, the first detected
storage in compilation will be using <code>0</code> as storage key.</p>
<pre><code class="language-solidity">// Loading storage at 0
PUSH0
SLOAD

// Loading storage at 1
PUSH1 0x01
SLOAD
</code></pre>
<h2 id="key-value"><a class="header" href="#key-value">Key-Value</a></h2>
<p>As mentioned above, all key-value pairs follows using number as storage key, however, the value
will be limited with 32 bytes, dynamic value like string is currently not supported.</p>
<h2 id="mapping"><a class="header" href="#mapping">Mapping</a></h2>
<p>Mapping keys are generated via <code>keccak256(slot, key)</code></p>
<h2 id="array"><a class="header" href="#array">Array</a></h2>
<p>Similar to mappings, but the keys will be using <code>u32</code> / <code>u64</code> for indexing due to the optimization
on the wasm side in the zink compiler, which means, the max size of an array is <code>max(u64)</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stability"><a class="header" href="#stability">Stability</a></h1>
<blockquote>
<p>This project is still under active development, please DO NOT use it in production.</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>version</th><th>description</th></tr></thead><tbody>
<tr><td><code>v0.1.0</code></td><td>The MVP of the zink project.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="v010---mvp"><a class="header" href="#v010---mvp"><code>v0.1.0</code> - MVP</a></h1>
<p>The MVP of the zink project, provides various tools for developing
EVM contracts with <code>rust</code> and <code>WASM</code>.</p>
<h2 id="binaries"><a class="header" href="#binaries">Binaries</a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>description</th></tr></thead><tbody>
<tr><td><code>elko</code></td><td>Zink’s package manager, can create and build zink project.</td></tr>
<tr><td><code>zinkc</code></td><td>The zink compiler, can compile simple wasm to EVM bytecode.</td></tr>
</tbody></table>
</div>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>description</th></tr></thead><tbody>
<tr><td><code>zinkgen</code></td><td>Zink code generator</td></tr>
<tr><td><code>zinkc</code></td><td>Zink compiler</td></tr>
<tr><td><code>zink</code></td><td>Rust library for developing program with zink</td></tr>
<tr><td><code>zint</code></td><td>Basic test utils including evm wrapper for testing usages</td></tr>
<tr><td><code>zinkup</code></td><td>Zink toolchain installer</td></tr>
</tbody></table>
</div>
<h2 id="functionality"><a class="header" href="#functionality">Functionality</a></h2>
<p>We provide basic functionalities in <code>v0.1.0</code> to verify thoughts, the final target
of it is example <code>fibonaaci</code>, which means, everything used in the <code>fibonacci</code> example
now works!</p>
<p>For supporting nearly everything, plz keep tuned for <code>v0.3.0</code>.</p>
<h3 id="arithmetic-1"><a class="header" href="#arithmetic-1">Arithmetic</a></h3>
<p><code>add</code>, <code>sub</code>, <code>mul</code> are available now, plus all comparison operand like <code>gt</code>, <code>lt</code>,
<code>ge</code>, <code>le</code>, <code>bitwise</code> also have implementations <strong>operators like <code>shr</code> require the
order of the stack will have bugs</strong>.</p>
<h3 id="locals-1"><a class="header" href="#locals-1">Locals</a></h3>
<p>The compilation of locals currently works without any hardcode, ideally, we don’t
need to refactor it in the future!</p>
<h3 id="calls-1"><a class="header" href="#calls-1">Calls</a></h3>
<p>Same as locals, works without any hardcode, but some logic related to the jump table
need to be refactored after introducing <code>selector</code>.</p>
<h3 id="control-flow-1"><a class="header" href="#control-flow-1">Control Flow</a></h3>
<p><code>if</code>, <code>else</code>, <code>block</code>, <code>loop</code>, <code>br_if</code> now works without any hardcode, need to add
<code>br_table</code>, <code>select</code>… to align wasm MVP in the future releases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security"><a class="header" href="#security">Security</a></h1>
<blockquote>
<p>TBS</p>
</blockquote>
<h2 id="mapping-of-instructions"><a class="header" href="#mapping-of-instructions">Mapping of Instructions</a></h2>
<h3 id="type-conversions"><a class="header" href="#type-conversions">Type Conversions</a></h3>
<p>WASM have <code>i32</code>, <code>i64</code>, <code>f32</code>, <code>f64</code> as number types while EVM bytecode
only supports arithmetic operations for 256-bits integers.</p>
<blockquote>
<p>TODO: Add more risk conditions.</p>
</blockquote>
<h3 id="stack-operations"><a class="header" href="#stack-operations">Stack Operations</a></h3>
<blockquote>
<p>TBA</p>
</blockquote>
<h3 id="memory-operations"><a class="header" href="#memory-operations">Memory Operations</a></h3>
<p>The memory related operations in WASM are dangerous for Zink’s implementation.</p>
<p>WASM is using 32-bits offsets from the MVP spec while EVM is using 256-bits offsets,
so it may cause memory overwrite problems.</p>
<p>The instructions need to be checked:</p>
<ul>
<li><code>i32.store</code></li>
<li><code>i64.store</code></li>
<li><code>f32.store</code></li>
<li><code>f64.store</code></li>
<li><code>i32.store8</code></li>
<li><code>i64.store8</code></li>
<li><code>i32.store16</code></li>
<li><code>i64.store16</code></li>
<li><code>memory.size</code></li>
<li><code>memory.grow</code></li>
</ul>
<p>TODO: check if it is possible to manage this issue with handling <code>memory.size</code> and <code>memory.grow</code>
in a proper way.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h1>
<p>This chapter terms to record the benchmarks of zink projects comparing
with <code>solidity</code> and <code>vyper</code>.</p>
<p>We are not going to compare with <code>yul</code> or <code>huff</code> since we are on different
level, however, if zink is even faster than <code>yul</code> or <code>huff</code> in some cases,
don’t be surprised, we are born with high performance.</p>
<ul>
<li><a href="benchmarks//benchmarks/fibonacci.html">Fibonacci</a></li>
<li><a href="benchmarks//benchmarks/storage.html">Storage</a></li>
</ul>
<h2 id="note"><a class="header" href="#note">NOTE</a></h2>
<p>since we haven’t implemented the selector logic yet, the bytecode of zink is
a bit shorter, similar in the gas cost, the main reason that zink contracts
cost less gas is that we are currently missing conditions for situations that
are more complex, we will get a more actual answer of these after the release of
<a href="https://github.com/zink-lang/zink/issues/69"><code>v0.2.0</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fibonacci-1"><a class="header" href="#fibonacci-1">Fibonacci</a></h1>
<p>Benchmarks for fibonacci.</p>
<p>Vyper is not included since it doesn’t support cyclic function call :(</p>
<h3 id="gas-cost"><a class="header" href="#gas-cost">Gas Cost</a></h3>
<div class="table-wrapper"><table><thead><tr><th>fib(n)</th><th>Zink</th><th>Solidity@0.8.21</th></tr></thead><tbody>
<tr><td>0</td><td>110</td><td>614</td></tr>
<tr><td>1</td><td>110</td><td>614</td></tr>
<tr><td>2</td><td>262</td><td>1322</td></tr>
<tr><td>3</td><td>414</td><td>2030</td></tr>
<tr><td>4</td><td>718</td><td>3446</td></tr>
<tr><td>5</td><td>1174</td><td>5570</td></tr>
</tbody></table>
</div>
<h3 id="runtime-code"><a class="header" href="#runtime-code">Runtime Code</a></h3>
<div class="table-wrapper"><table><thead><tr><th>zink</th><th>solidity</th></tr></thead><tbody>
<tr><td>146</td><td>1052</td></tr>
</tbody></table>
</div>
<h2 id="zink"><a class="header" href="#zink"><code>zink</code></a></h2>
<pre><code class="language-rust">//! Zink fibonacci recursion

#[no_mangle]
pub extern "C" fn fib(n: usize) -&gt; usize {
    if n &lt; 2 {
        n
    } else {
        recursion(n - 1) + recursion(n - 2)
    }
}</code></pre>
<pre><code>600035586010565b60005260206000f35b906000816002600190031015603d575b8160019003586010565b8101905081600290038092506001106020575b8181019150509060040156
</code></pre>
<h2 id="solidity"><a class="header" href="#solidity"><code>solidity</code></a></h2>
<pre><code class="language-sol">/**
 * Solidity fibonacci recursion
 **/

function fib(uint n) public view returns (uint) {
  if (n &lt; 2) {
    return n;
  } else {
    return fib(n - 1) + fib(n - 2);
  }
}
</code></pre>
<pre><code>608060405234801561001057600080fd5b506004361061002b5760003560e01c8063c6c2ea1714610030575b600080fd5b61004a600480360381019061004591906100ea565b610060565b6040516100579190610126565b60405180910390f35b60006002821015610073578190506100aa565b6100886002836100839190610170565b610060565b61009d6001846100989190610170565b610060565b6100a791906101a4565b90505b919050565b600080fd5b6000819050919050565b6100c7816100b4565b81146100d257600080fd5b50565b6000813590506100e4816100be565b92915050565b600060208284031215610100576100ff6100af565b5b600061010e848285016100d5565b91505092915050565b610120816100b4565b82525050565b600060208201905061013b6000830184610117565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061017b826100b4565b9150610186836100b4565b925082820390508181111561019e5761019d610141565b5b92915050565b60006101af826100b4565b91506101ba836100b4565b92508282019050808211156101d2576101d1610141565b5b9291505056fea2646970667358221220f28552ff642c48025f3617233333427ae50d06ce8b168d3e3e9c18f0cf9bc34d64736f6c63430008120033
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="log-1"><a class="header" href="#log-1">Log</a></h1>
<p>Zink only supports static byte array for log arguments for now, see issue
<a href="https://github.com/zink-lang/zink/issues/129">#129</a> for more details.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Zink</th><th>Vyper@0.3.9</th><th>Solidity@0.8.21</th></tr></thead><tbody>
<tr><td>Gas Cost</td><td>1031</td><td>2777</td><td>2894</td></tr>
<tr><td>Runtime Code</td><td>42</td><td>632</td><td>774</td></tr>
</tbody></table>
</div>
<h2 id="zink-1"><a class="header" href="#zink-1"><code>zink</code></a></h2>
<pre><code class="language-rust">//! Addition example.
#![no_std]

// for the panic handler.
#[cfg(not(test))]
extern crate zink;

use zink::Event;

/// A `Ping` event.
///
/// TODO: generate this with proc-macro.
struct Ping;

/// TODO: generate this with proc-macro.
impl Event for Ping {
    const NAME: &amp;'static [u8] = b"Ping";
}

#[no_mangle]
pub extern "C" fn log1() {
    Ping.log1(b"pong");
}</code></pre>
<pre><code>63706f6e676350696e6760005260206000a15f5ff3
</code></pre>
<h2 id="vyper"><a class="header" href="#vyper"><code>vyper</code></a></h2>
<pre><code class="language-python">event Ping:
  name: String[4]
  topic1: String[4]

@external
def l():
  log Ping("Ping", "pong")
</code></pre>
<pre><code>6003361161000c57610127565b5f3560e01c3461012b5763ece866b98118610125577fcf8d08d4ab9d61004e3c20715af5b44c3badc3d3f41ddccbedbef447355ebff460408060c05260046040527f50696e670000000000000000000000000000000000000000000000000000000060605260408160c00181516020830160208301815181525050808252508051806020830101601f825f03163682375050601f19601f8251602001011690509050810190508060e05260046080527f706f6e670000000000000000000000000000000000000000000000000000000060a05260808160c00181516020830160208301815181525050808252508051806020830101601f825f03163682375050601f19601f82516020010116905090508101905060c0a1005b505b5f5ffd5b5f80fda165767970657283000309000b
</code></pre>
<h2 id="solidity-1"><a class="header" href="#solidity-1"><code>solidity</code></a></h2>
<pre><code class="language-sol">// SPDX-License-Identifier: MIT
pragma solidity &gt;=0.7.0 &lt;0.9.0;

contract Test {
  event Ping(string name, string topic);

  function l() public {
    emit Ping("Ping", "pong");
  }
}
</code></pre>
<pre><code>608060405234801561001057600080fd5b506004361061002b5760003560e01c8063ece866b914610030575b600080fd5b61003861003a565b005b7fcf8d08d4ab9d61004e3c20715af5b44c3badc3d3f41ddccbedbef447355ebff46040516100679061011a565b60405180910390a1565b600082825260208201905092915050565b7f50696e6700000000000000000000000000000000000000000000000000000000600082015250565b60006100b8600483610071565b91506100c382610082565b602082019050919050565b7f706f6e6700000000000000000000000000000000000000000000000000000000600082015250565b6000610104600483610071565b915061010f826100ce565b602082019050919050565b60006040820190508181036000830152610133816100ab565b90508181036020830152610146816100f7565b905091905056fea26469706673582212201af2a7b1c1d4743d1d089d3eaa1bbd6ecb4186fc95a43320108b18882d7a6dfc64736f6c63430008120033
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-2"><a class="header" href="#storage-2">Storage</a></h1>
<p>Result for a simple storage IO.</p>
<p>Have to say <code>Vyper</code> is super on this even it contains the logic of function
selector!</p>
<h3 id="gas-cost-1"><a class="header" href="#gas-cost-1">Gas Cost</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Zink</th><th>Vyper@0.3.9</th><th>Solidity@0.8.21</th></tr></thead><tbody>
<tr><td>22237</td><td>22345</td><td>27738</td></tr>
</tbody></table>
</div>
<p>The gas costs here are measured by <code>transaction cost</code> + <code>execution cost</code>,
for example, the transaction of this function in solidity is <code>24120</code>, and
<code>2916</code> for the execution cost, <code>27738</code> in total.</p>
<p>Since revm doesn’t support this and we haven’t implemented the constructor
yet, we don’t have the separated costs for zink for now ))</p>
<p>Issues: <a href="https://github.com/zink-lang/zink/issues/102">zink-lang/zink#102</a>, <a href="https://github.com/bluealloy/revm/issues/619">bluealloy/revm#619</a></p>
<h3 id="runtime-code-1"><a class="header" href="#runtime-code-1">Runtime Code</a></h3>
<div class="table-wrapper"><table><thead><tr><th>zink</th><th>vyper</th><th>solidity</th></tr></thead><tbody>
<tr><td>42</td><td>204</td><td>724</td></tr>
</tbody></table>
</div>
<h2 id="zink-2"><a class="header" href="#zink-2"><code>zink</code></a></h2>
<pre><code class="language-rust">/// TODO: generate this storage interface with proc macro.
struct Counter;

impl Counter {
    fn get() -&gt; i64 {
        unsafe { sload(0) }
    }

    fn set(value: i64) {
        unsafe { sstore(0, value) }
    }
}

/// Set value to the storage and get it.
#[no_mangle]
pub unsafe extern "C" fn set_and_get(value: i64) -&gt; i64 {
    Counter::set(value);
    Counter::get()
}</code></pre>
<pre><code>6000600035589155600058905460005260206000f3
</code></pre>
<h2 id="vyper-1"><a class="header" href="#vyper-1"><code>vyper</code></a></h2>
<pre><code class="language-python">n: public(int256)

@external
def sg(_n: int256) -&gt; int256:
  self.n = _n
  return self.n
</code></pre>
<pre><code>6003361161000c57610051565b5f3560e01c3461005557632e52d606811861002c575f5460405260206040f35b63da48b556811861004f5760243610610055576004355f555f5460405260206040f35b505b5f5ffd5b5f80fda165767970657283000309000b
</code></pre>
<h2 id="solidity-2"><a class="header" href="#solidity-2"><code>solidity</code></a></h2>
<pre><code class="language-sol">pragma solidity &gt;=0.7.0 &lt;0.9.0;

contract Storage {
  int public number;

  function sg(int n) public returns (int) {
    number = n;
    return number;
  }
}
</code></pre>
<pre><code>608060405234801561001057600080fd5b50600436106100365760003560e01c80638381f58a1461003b578063da48b55614610059575b600080fd5b610043610089565b60405161005091906100bb565b60405180910390f35b610073600480360381019061006e9190610107565b61008f565b60405161008091906100bb565b60405180910390f35b60005481565b6000816000819055506000549050919050565b6000819050919050565b6100b5816100a2565b82525050565b60006020820190506100d060008301846100ac565b92915050565b600080fd5b6100e4816100a2565b81146100ef57600080fd5b50565b600081359050610101816100db565b92915050565b60006020828403121561011d5761011c6100d6565b5b600061012b848285016100f2565b9150509291505056fea264697066735822122052e14a565911c984f75788fb539e44d7692065628b2042665fc4abfc95e680d264736f6c63430008120033
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-tool"><a class="header" href="#command-line-tool">Command Line Tool</a></h1>
<p>The zink toolchain are gathered in <a href="https://crates.io/crates/zinkup">zinkup</a></p>
<p>You can install all of the components directly with:</p>
<pre><code class="language-bash">cargo install zinkup
</code></pre>
<p>For installing only specified binaries:</p>
<pre><code class="language-bash">cargo install zinkup --features elko,zinkc
</code></pre>
<p>Available binaries:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>elko</code></td><td>Zink's package manager</td></tr>
<tr><td><code>zinkc</code></td><td>The zink compiler</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="elko---zinks-package-manager"><a class="header" href="#elko---zinks-package-manager"><code>elko</code> - Zink’s package manager</a></h1>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<pre><code class="language-bash">cargo install zinkup --features elko
</code></pre>
<h2 id="usages"><a class="header" href="#usages">Usages</a></h2>
<pre><code class="language-bash">elko
Package manager of zink.

Usage: elko [OPTIONS] &lt;COMMAND&gt;

Commands:
  new    Create a new zink project
  build  Build zink project to EVM bytecode
  help   Print this message or the help of the given subcommand(s)

Options:
  -v, --verbose...  Verbose mode (-v, -vv, -vvv, etc.)
  -h, --help        Print help
  -V, --version     Print version
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-zink-compiler"><a class="header" href="#the-zink-compiler">The zink compiler</a></h1>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<pre><code>cargo install zinkup --features zinkc
</code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><code class="language-bash">The Zink Compiler

Usage: zinkc [OPTIONS] &lt;INPUT&gt;

Arguments:
  &lt;INPUT&gt;  The path of the wasm file

Options:
  -o, --output &lt;OUTPUT&gt;  Write output to &lt;filename&gt;
  -v, --verbose...       Verbose mode (-v, -vv, -vvv, etc.)
  -h, --help             Print help
  -V, --version          Print version
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>We’re excited to work on <code>Zink</code> together with you! this guide should help you
get up and running with Zink development!</p>
<h2 id="join-our-chat"><a class="header" href="#join-our-chat">Join Our Chat</a></h2>
<p>We chat about Zink development on telegram – <a href="https://t.me/+6oZpbwxlVD81OGQ1">join us</a>!</p>
<p>If you’re having building Zink, aren’t sure why a test is failing, or have any
other questions, feel free to ask on telegram.</p>
<p>As always, you’re more than welcome to <a href="https://github.com/clearloop/zink/issues/new/choose">open an issue</a> too!</p>
<h2 id="join-or-support-the-team"><a class="header" href="#join-or-support-the-team">Join or Support the Team</a></h2>
<p>Zink is developed by <a href="https://github.com/clearloop">@clearloop</a> with his spare time for now, really
need more hands for the revolution : )</p>
<p>My handle on telegram is <code>@clearloop</code> as well, if you’d like to support this
project or join the team, dm me plz!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-of-zink"><a class="header" href="#architecture-of-zink">Architecture of Zink</a></h1>
<h2 id="compiler-1"><a class="header" href="#compiler-1">Compiler</a></h2>
<p>The path of the compiler crate is <code>/compiler</code>, as its name, it’s the zink compiler
<code>zinkc</code>, currently just a wrapper of <code>zingen</code>, the codegen library.</p>
<p>So if you want to contribute to the compiler, the code inside <code>/compiler</code> and <code>/codegen</code>
will be interested for you!</p>
<h2 id="zink-3"><a class="header" href="#zink-3">Zink</a></h2>
<p>Located at <code>/zink</code>, it is a rust library for compiling cargo project to zink program
with provided apis, <code>selector</code>, <code>events</code>…any sugar or asm macro for zink will be
embedded in this library.</p>
<h2 id="test-utils"><a class="header" href="#test-utils">Test utils</a></h2>
<p><code>/zint</code> is the testing library for zink projects, it is currently just a wrapper
of <code>evm</code>, we need really a lot of features in this in <code>v0.3.0</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bounties"><a class="header" href="#bounties">Bounties</a></h1>
<p>We have bounty issues layout in <a href="https://zink-lang.org/bounties">zink-lang.org</a>.</p>
<p>If you are solving a bounty issue, please add your wallet address in your PR description, We
will send you the bounty once the PR is merged.</p>
<p>for example:</p>
<pre><code class="language-md">## Changes

- [x] step 1
- [ ] ...

Polygon Address: `0x0000000000000000000000000000000000000000`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building"><a class="header" href="#building">Building</a></h1>
<p>This section describes everything required to build and run zink.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Before we can actually build Zink, we’ll need to make sure these things are installed first.</p>
<h3 id="the-rust-toolchain"><a class="header" href="#the-rust-toolchain">The Rust toolchain</a></h3>
<p><a href="https://www.rust-lang.org/tools/install">Install the Rust toolchain here</a>. This includes <code>rustup</code>, <code>cargo</code>, <code>rustc</code>, etc…</p>
<h3 id="add-target-wasm32-unknown-unknown"><a class="header" href="#add-target-wasm32-unknown-unknown">Add target <code>wasm32-unknown-unknown</code></a></h3>
<pre><code>rustup target add wasm32-unknown-unknown
</code></pre>
<p>This is required for compiling our rust projects to wasm.</p>
<h2 id="build-the-zinkc-cli"><a class="header" href="#build-the-zinkc-cli">Build the <code>zinkc</code> CLI</a></h2>
<pre><code class="language-bash">cd cli
cargo b -p zinkup --release --features zinkc
</code></pre>
<p>The built executable will be located at <code>target/release/zinkc</code>.</p>
<h2 id="build-examples"><a class="header" href="#build-examples">Build examples</a></h2>
<pre><code class="language-bash">cd examples
cargo b --release
</code></pre>
<p>The built wasm binaries will be localted at <code>examples/target/wasm32-unknown-unknown/realease/*.wasm</code>,
then, you can you <code>zinkc</code> to compile them to EVM bytecode!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="shortcuts"><a class="header" href="#shortcuts">Shortcuts</a></h2>
<p>while developing zink, you may find the shortcuts below helpful:</p>
<pre><code class="language-bash"># Clippy all packages
cargo cc

# Run all tests
cargo tt

# Build all examples
cargo be

# Run tests for examples
cargo te
</code></pre>
<p>They are layout in <a href="https://github.com/zink-lang/zink/blob/main/.cargo/config.toml"><code>/.cargo/config.toml</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>This section describes how to run Zink’s tests and add new tests.</p>
<p>Before continuing, make sure you can build Zink successfully. Can’t
run the tests if you can’t build it!</p>
<h2 id="running-all-tests"><a class="header" href="#running-all-tests">Running All Tests</a></h2>
<pre><code class="language-bash">cargo test --all
</code></pre>
<h2 id="adding-new-tests-for-the-compiler"><a class="header" href="#adding-new-tests-for-the-compiler">Adding New Tests for the Compiler</a></h2>
<p>At the current stage, we are lack of the tests of the compiler,
the tests of it are gathered in <code>compiler/tests</code>.</p>
<p>Each file under <code>compiler/tests</code> are named by instruction, for
example <code>add.rs</code>, it includes the tests related to instruction
<code>ADD</code>.</p>
<p>For adding a new test for <code>compiler/tests/add.rs</code>, we need to write
a wasm program for it first, for example, the wasm program of the
<code>params</code> test of <code>ADD</code> is located at <code>compiler/wat/i32add/params.wat</code>.</p>
<pre><code class="language-wasm">(module
    (func (param i32) (param i32) (result i32)
    (local.get 0)
    (local.get 1)
    (i32.add)
    )
)
</code></pre>
<p>In <code>compiler/tests/add.rs</code>:</p>
<pre><code class="language-rust">#[test]
fn params() -&gt; Result&lt;()&gt; {
    let bytecode = common::load("i32add", "params")?;

    // add(1, 2)
    let input = [1.to_bytes32(), 2.to_bytes32()].concat();
    let info = EVM::run(&amp;bytecode, &amp;input);

    assert_eq!(info.ret, [3.to_bytes32()].concat());
    Ok(())
}</code></pre>
<p>We use <code>common::load("i32add", "params")</code> to load wat file to EVM bytecode
from <code>compiler/tests/wat/i32add/params.wat</code>, execute with the <code>EVM</code> provided
by <code>zint</code>, compare if the result is as expected, that’s it!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<p>The following sections contain reference material you may find useful
in your Zink journey.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a---optimizations"><a class="header" href="#a---optimizations">A - Optimizations</a></h1>
<p>The optimizations of Zink projects now are mainly benefited from
the optimizer of wasm – <code>wasm-opt</code>, for the details of it please
check <a href="https://github.com/WebAssembly/binaryen#binaryen-optimizations">Binary Optimizations</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
